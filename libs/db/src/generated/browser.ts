
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/*
 * This file should be your main import to use Prisma-related types and utilities in a browser. 
 * Use it to get access to models, enums, and input types.
 * 
 * This file does not contain a `PrismaClient` class, nor several other helpers that are intended as server-side only.
 * See `client.ts` for the standard, server-side entry point.
 *
 * ðŸŸ¢ You can import this file directly.
 */

import * as Prisma from './internal/prismaNamespaceBrowser'
export { Prisma }
export * as $Enums from './enums'
export * from './enums';
/**
 * Model User
 * 
 */
export type User = Prisma.UserModel
/**
 * Model Profile
 * 
 */
export type Profile = Prisma.ProfileModel
/**
 * Model UserAuth
 * 
 */
export type UserAuth = Prisma.UserAuthModel
/**
 * Model UserStats
 * 
 */
export type UserStats = Prisma.UserStatsModel
/**
 * Model DeletedUser
 * 
 */
export type DeletedUser = Prisma.DeletedUserModel
/**
 * Model Report
 * 
 */
export type Report = Prisma.ReportModel
/**
 * Model Activity
 * 
 */
export type Activity = Prisma.ActivityModel
/**
 * Model Follow
 * 
 */
export type Follow = Prisma.FollowModel
/**
 * Model Notification
 * 
 */
export type Notification = Prisma.NotificationModel
/**
 * Model MapNotify
 * 
 */
export type MapNotify = Prisma.MapNotifyModel
/**
 * Model MMap
 * The term 'MMap' is used to avoid collisions with the JS data structure, just
 * in cases where the exact name "Map" is used.
 */
export type MMap = Prisma.MMapModel
/**
 * Model MapVersion
 * 
 */
export type MapVersion = Prisma.MapVersionModel
/**
 * Model MapCredit
 * 
 */
export type MapCredit = Prisma.MapCreditModel
/**
 * Model MapFavorite
 * 
 */
export type MapFavorite = Prisma.MapFavoriteModel
/**
 * Model MapInfo
 * 
 */
export type MapInfo = Prisma.MapInfoModel
/**
 * Model MapStats
 * 
 */
export type MapStats = Prisma.MapStatsModel
/**
 * Model MapTestInvite
 * 
 */
export type MapTestInvite = Prisma.MapTestInviteModel
/**
 * Model MapSubmission
 * 
 */
export type MapSubmission = Prisma.MapSubmissionModel
/**
 * Model MapSubmissionDate
 * 
 */
export type MapSubmissionDate = Prisma.MapSubmissionDateModel
/**
 * Model MapReview
 * 
 */
export type MapReview = Prisma.MapReviewModel
/**
 * Model MapReviewComment
 * 
 */
export type MapReviewComment = Prisma.MapReviewCommentModel
/**
 * Model MapReviewStats
 * 
 */
export type MapReviewStats = Prisma.MapReviewStatsModel
/**
 * Model Leaderboard
 * This table stores what a tracks on a map a run can be submitted to, in what
 * gamemode and style, plus metadata about that track in that gamemode e.g. its
 * tier and type.
 * 
 * For example, surf_utopia probably just gets gamemode = Gamemode.SURF,
 * trackType = TrackType.MAIN, trackNum = 0 entries, for all the styles surf
 * supports, with type = LeaderboardType.RANKED.
 * A mode that supports several different gamemodes, and has stages,
 * bonuses etc. is likely to have dozens of different entries, perhaps some
 * ranked, others unranked, some hidden.
 */
export type Leaderboard = Prisma.LeaderboardModel
/**
 * Model LeaderboardRun
 * This table stores runs _on a leaderboard_. An entry is a unique
 * instance of a userID and the fields that constitute a Leaderboard (`mapID`,
 * `gamemode`, `trackType`, `trackNum`, `style`). By using that combination in
 * our PK, we ensure those entries are unique at a DB level.
 * 
 * We use B-Tree two indexes
 * - (userID, gamemode, style, mapID, trackType, trackNum): For fetching runs by user for e.g. profile page.
 * Also is a UNIQUE constraint.
 * - (mapID, gamemode, trackType, trackNum, style, time (asc), createdAt (asc)): Indexes in leaderboard order.
 * The idea is we get every distinct leaderboard stacked on top of each other, then ordered by time within the chunk,
 * where ties are simply handled by whatever was submitted first. Note that we store any actual "rank" values - incrementing
 * ranks for all slower runs on a leaderboard is an incredibly slow operation. (TODO: This hasn't been implemented yet).
 * Instead, we index this way to allow us to very efficiently compute ranks per query using window functions.
 */
export type LeaderboardRun = Prisma.LeaderboardRunModel
/**
 * Model PastRun
 * Very similar to `LeaderboardRun`, but also includes non-PB runs, and
 * therefore doesn't really correspond to a leaderboard - rather all the runs
 * that ever qualified for that leaderboard in the past. Used for tracking
 * user's run history.
 */
export type PastRun = Prisma.PastRunModel
/**
 * Model AdminActivity
 * 
 */
export type AdminActivity = Prisma.AdminActivityModel
/**
 * Model Config
 * Not standard SQL practice but whatever, this is a solid way to persist
 * config
 */
export type Config = Prisma.ConfigModel
