
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "./prismaNamespace"


const config: runtime.GetPrismaClientConfig = {
  "generator": {
    "name": "client",
    "provider": {
      "fromEnvVar": null,
      "value": "prisma-client"
    },
    "output": {
      "value": "F:\\momentum-mod-website\\libs\\db\\src\\generated",
      "fromEnvVar": null
    },
    "config": {
      "engineType": "client"
    },
    "binaryTargets": [
      {
        "fromEnvVar": null,
        "value": "windows",
        "native": true
      }
    ],
    "previewFeatures": [
      "typedSql"
    ],
    "sourceFilePath": "F:\\momentum-mod-website\\libs\\db\\src\\schema.prisma",
    "isCustomOutput": true
  },
  "relativePath": "..",
  "clientVersion": "6.16.2",
  "engineVersion": "1c57fdcd7e44b29b9313256c76699e91c3ac3c43",
  "datasourceNames": [
    "db"
  ],
  "activeProvider": "postgresql",
  "inlineDatasources": {
    "db": {
      "url": {
        "fromEnvVar": "DATABASE_URL",
        "value": null
      }
    }
  },
  "inlineSchema": "generator client {\n  provider        = \"prisma-client\"\n  output          = \"./generated/\"\n  engineType      = \"client\"\n  previewFeatures = [\"typedSql\"]\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// NOTE: ? after type in this file means field can be null (but still exists).\n\nmodel User {\n  id Int @id @default(autoincrement())\n\n  roles Int @default(0) @db.SmallInt /// Flags of roles.enum.ts\n  bans  Int @default(0) @db.SmallInt /// Flags of bans.enum.ts\n\n  /// Optional because placeholders don't have SteamIDs\n  steamID BigInt? @unique(map: \"user_steamID\") @db.BigInt\n  alias   String\n  avatar  String?\n  country String? @db.Char(2)\n\n  profile              Profile?\n  userStats            UserStats?\n  submittedMaps        MMap[]\n  submittedMapDates    MapSubmissionDate[]\n  submittedMapVersions MapVersion[]\n  mapCredits           MapCredit[]\n  mapFavorites         MapFavorite[]\n  activities           Activity[]\n  follows              Follow[]            @relation(\"follow_follow\")\n  followers            Follow[]            @relation(\"follow_follower\")\n  mapNotifies          MapNotify[]\n  notifications        Notification[]      @relation(\"notifs_to\")\n  notifsAbout          Notification[]      @relation(\"notifs_about\")\n  leaderboardRuns      LeaderboardRun[]\n  pastRuns             PastRun[]\n  reportSubmitted      Report[]            @relation(\"report_submitter\")\n  reportResolved       Report[]            @relation(\"report_resolver\")\n  testInvites          MapTestInvite[]\n  reviewsSubmitted     MapReview[]         @relation(\"mapreview_reviewer\")\n  reviewsResolved      MapReview[]         @relation(\"mapreview_resolver\")\n  reviewComments       MapReviewComment[]\n  adminActivities      AdminActivity[]\n\n  createdAt DateTime @default(now())\n}\n\nmodel Profile {\n  bio     String @default(\"\")\n  socials Json? /// Socials model\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)\n  userID Int  @id\n}\n\nmodel UserStats {\n  totalJumps    BigInt @default(0) @db.BigInt\n  totalStrafes  BigInt @default(0) @db.BigInt\n  level         Int    @default(1) @db.SmallInt\n  cosXP         BigInt @default(0) @db.BigInt\n  mapsCompleted Int    @default(0)\n  runsSubmitted Int    @default(0)\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)\n  userID Int  @id\n}\n\nmodel DeletedUser {\n  steamIDHash String @id @db.Char(64) /// SHA-256 hex hash of steamID\n}\n\nmodel Report {\n  id Int @id @default(autoincrement())\n\n  type              Int      @db.SmallInt /// report-type.enum.ts\n  /// This is used as a primary key into one of many possible tables,\n  /// determined by the value of `type`.\n  data              BigInt   @db.BigInt\n  category          Int      @db.SmallInt\n  message           String?\n  resolved          Boolean? @default(false)\n  resolutionMessage String?\n\n  submitter   User? @relation(\"report_submitter\", fields: [submitterID], references: [id], onDelete: SetNull)\n  submitterID Int?\n\n  resolver   User? @relation(\"report_resolver\", fields: [resolverID], references: [id], onDelete: SetNull)\n  resolverID Int?\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@index([resolverID, submitterID])\n}\n\nmodel Activity {\n  id Int @id @default(autoincrement())\n\n  type Int @default(0) @db.SmallInt /// activity-type.enum.ts\n\n  /// This is used as a primary key into one of many possible tables,\n  /// determined by the value of `type`.\n  data BigInt @db.BigInt\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)\n  userID Int\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@index([userID])\n}\n\nmodel Follow {\n  notifyOn Int @default(0) @db.SmallInt /// Flags of activity-type.enum.ts\n\n  followed   User @relation(\"follow_follower\", fields: [followedID], references: [id], onDelete: Cascade)\n  followedID Int\n\n  followee   User @relation(\"follow_follow\", fields: [followeeID], references: [id], onDelete: Cascade)\n  followeeID Int\n\n  createdAt DateTime @default(now())\n\n  @@id([followeeID, followedID])\n}\n\nmodel Notification {\n  id Int @id @default(autoincrement())\n\n  type Int /// notification-type.enum.ts\n\n  isRead Boolean @default(false)\n\n  //  Object containing non-nested fields (non-relations) of Notification variants.\n  //  AnnouncementNotification fields:\n  //  json: {\n  //    message: string;\n  //  }\n  //  WRAchievedNotification fields:\n  //  json: {\n  //    TODO\n  //  }\n  //  MapStatusChangeNotification fields:\n  //  json: {\n  //    oldStatus: MapStatus;\n  //    newStatus: MapStatus;\n  //  }\n  json Json? @default(\"{}\")\n\n  notifiedUser   User @relation(\"notifs_to\", fields: [notifiedUserID], references: [id], onDelete: Cascade)\n  notifiedUserID Int\n\n  user   User? @relation(\"notifs_about\", fields: [userID], references: [id], onDelete: Cascade)\n  userID Int?\n\n  map   MMap? @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int?\n\n  review   MapReview? @relation(fields: [reviewID], references: [id], onDelete: Cascade)\n  reviewID Int?\n\n  reviewComment   MapReviewComment? @relation(fields: [reviewCommentID], references: [id], onDelete: Cascade)\n  reviewCommentID Int?\n\n  createdAt DateTime @default(now())\n\n  @@index(notifiedUserID)\n}\n\nmodel MapNotify {\n  notifyOn Int @db.SmallInt /// Flags of activity-type.enum.ts\n\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)\n  userID Int\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@id([userID, mapID])\n}\n\n/// The term 'MMap' is used to avoid collisions with the JS data structure, just\n/// in cases where the exact name \"Map\" is used.\nmodel MMap {\n  id Int @id @default(autoincrement())\n\n  name   String   @unique\n  status Int      @db.SmallInt /// map-status.enum.ts\n  images String[]\n\n  submitter   User? @relation(fields: [submitterID], references: [id], onDelete: SetNull)\n  submitterID Int?\n\n  stats MapStats?\n  info  MapInfo?\n\n  currentVersion   MapVersion? @relation(name: \"current_version\", fields: [currentVersionID], references: [id])\n  currentVersionID String?     @unique @db.Uuid\n\n  versions        MapVersion[]\n  leaderboards    Leaderboard[]\n  leaderboardRuns LeaderboardRun[]\n  pastRuns        PastRun[]\n  credits         MapCredit[]\n  favorites       MapFavorite[]\n  notifies        MapNotify[]\n  notifsAbout     Notification[]\n  reviews         MapReview[]\n  reviewStats     MapReviewStats?\n  submission      MapSubmission?\n  testInvites     MapTestInvite[]\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  // This table is quite small but queried very frequently, so makes sense to index quite a few things.\n  // @unique on name provides an index.\n  @@index([submitterID])\n  @@index([status, createdAt(sort: Desc)])\n}\n\nmodel MapVersion {\n  id String @id @default(uuid()) @db.Uuid // BSP file stored relative to this\n\n  versionNum    Int     @db.SmallInt\n  changelog     String?\n  bspHash       String? @db.Char(40) // Nullable as we set to null if we delete files if map gets \"deleted\" (disabled)\n  zoneHash      String? @db.Char(40) // Nullable as we set to null if we delete files if map gets \"deleted\" (disabled)\n  bspDownloadId String? @db.Uuid // Nullable as we set to null if we delete files if map gets \"deleted\" (disabled)\n  vmfDownloadId String? @db.Uuid // Nullable as map may not have vmf\n  // Stringified JSON of MapZones model\n  // We don't gain anything from storing as jsonb, text is (presumably) faster\n  // and preserves whitespace so zoneHash is reliable.\n  zones         String?\n\n  submitterID Int?\n  submitter   User? @relation(fields: [submitterID], references: [id])\n\n  currentVersion MMap? @relation(name: \"current_version\")\n\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int\n\n  createdAt DateTime @default(now())\n\n  @@index([mapID])\n}\n\nmodel MapCredit {\n  type        Int     @db.SmallInt /// map-credit-type.enum.ts\n  description String?\n\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)\n  userID Int\n\n  @@id([mapID, userID])\n  @@index([mapID])\n}\n\nmodel MapFavorite {\n  id Int @id @default(autoincrement())\n\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)\n  userID Int\n\n  createdAt DateTime @default(now())\n\n  @@unique([mapID, userID])\n}\n\nmodel MapInfo {\n  description   String    @default(\"\")\n  youtubeID     String?\n  creationDate  DateTime  @db.Date\n  approvedDate  DateTime?\n  requiredGames Int[]     @default([]) /// steam-game.enum.ts\n\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int  @unique\n\n  @@id([mapID])\n}\n\nmodel MapStats {\n  reviews           Int    @default(0)\n  subscriptions     Int    @default(0)\n  plays             Int    @default(0)\n  favorites         Int    @default(0)\n  completions       Int    @default(0)\n  uniqueCompletions Int    @default(0)\n  timePlayed        BigInt @default(0) @db.BigInt\n\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int  @id\n}\n\nmodel MapTestInvite {\n  mapID Int\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n\n  userID Int\n  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)\n\n  state Int @db.SmallInt /// map-testing-request-state.enum.ts\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@id([mapID, userID])\n}\n\nmodel MapSubmission {\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int  @id\n\n  type Int @db.SmallInt /// map-submission-type.enum.ts\n\n  /// Array of MapSubmissionSuggestion model\n  suggestions         Json                @default(\"[]\")\n  /// Array of MapSubmissionPlaceholder model\n  placeholders        Json?\n  dates               MapSubmissionDate[]\n  discordReviewThread String?\n}\n\nmodel MapSubmissionDate {\n  id Int @id @default(autoincrement())\n\n  status Int      @db.SmallInt /// map-status.enum.ts\n  date   DateTime @default(now())\n\n  user   User? @relation(fields: [userID], references: [id], onDelete: SetNull)\n  userID Int?\n\n  submission      MapSubmission @relation(fields: [submissionMapID], references: [mapID], onDelete: Cascade)\n  submissionMapID Int\n\n  @@index([submissionMapID])\n}\n\n// This model will be greatly expanded in the future to include screenshots,\n// replays, savestates etc.\nmodel MapReview {\n  id Int @id @default(autoincrement())\n\n  mainText    String\n  comments    MapReviewComment[]\n  suggestions Json               @default(\"[]\") /// Array of MapSubmissionSuggestion model\n  editHistory Json               @default(\"[]\") /// Array of MapReviewEdit model\n  imageIDs    String[]\n\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int\n\n  reviewer   User @relation(name: \"mapreview_reviewer\", fields: [reviewerID], references: [id], onDelete: Cascade)\n  reviewerID Int\n\n  resolved   Boolean? /// If NULL, the review does not need resolving to pass to FINAL_APPROVAL\n  resolver   User?    @relation(name: \"mapreview_resolver\", fields: [resolverID], references: [id], onDelete: Cascade)\n  resolverID Int?\n\n  approves Boolean @default(false)\n\n  notifsAbout Notification[]\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@index([mapID])\n}\n\nmodel MapReviewComment {\n  id Int @id @default(autoincrement())\n\n  text String\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)\n  userID Int\n\n  review   MapReview @relation(fields: [reviewID], references: [id], onDelete: Cascade)\n  reviewID Int\n\n  notifsAbout Notification[]\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@index([reviewID, createdAt])\n}\n\n// I'd really like to use a view for this but Prisma support is too limited.\nmodel MapReviewStats {\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int  @id\n\n  total      Int @default(0)\n  approvals  Int @default(0)\n  resolved   Int @default(0)\n  unresolved Int @default(0)\n}\n\n/// This table stores what a tracks on a map a run can be submitted to, in what\n/// gamemode and style, plus metadata about that track in that gamemode e.g. its\n/// tier and type.\n///\n/// For example, surf_utopia probably just gets gamemode = Gamemode.SURF,\n/// trackType = TrackType.MAIN, trackNum = 0 entries, for all the styles surf\n/// supports, with type = LeaderboardType.RANKED.\n/// A mode that supports several different gamemodes, and has stages,\n/// bonuses etc. is likely to have dozens of different entries, perhaps some\n/// ranked, others unranked, some hidden.\nmodel Leaderboard {\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int\n\n  gamemode  Int @db.SmallInt\n  trackType Int @db.SmallInt\n  trackNum  Int @db.SmallInt\n  style     Int @db.SmallInt\n\n  // Optional as these don't necessarily apply to stages/bonuses\n  tier   Int?     @db.SmallInt\n  linear Boolean?\n\n  type Int @db.SmallInt // leaderboard-type.enum.ts\n\n  // We could do a separate table for this, which maaay have a perf increase\n  // (haven't tested), but complicates code a lot. Tag filtering is done on the\n  // game client anyway, so performance isn't a huge issue.\n  tags Int[] @db.SmallInt /// Array of MapTag\n\n  runs LeaderboardRun[]\n\n  @@id([mapID, gamemode, trackType, trackNum, style])\n}\n\n/// This table stores runs _on a leaderboard_. An entry is a unique\n/// instance of a userID and the fields that constitute a Leaderboard (`mapID`,\n/// `gamemode`, `trackType`, `trackNum`, `style`). By using that combination in\n/// our PK, we ensure those entries are unique at a DB level.\n///\n/// We use B-Tree two indexes\n///   - (userID, gamemode, style, mapID, trackType, trackNum): For fetching runs by user for e.g. profile page.\n///     Also is a UNIQUE constraint.\n///   - (mapID, gamemode, trackType, trackNum, style, time (asc), createdAt (asc)): Indexes in leaderboard order.\n///     The idea is we get every distinct leaderboard stacked on top of each other, then ordered by time within the chunk,\n///     where ties are simply handled by whatever was submitted first. Note that we store any actual \"rank\" values - incrementing\n///     ranks for all slower runs on a leaderboard is an incredibly slow operation. (TODO: This hasn't been implemented yet).\n///     Instead, we index this way to allow us to very efficiently compute ranks per query using window functions.\nmodel LeaderboardRun {\n  leaderboard Leaderboard @relation(fields: [mapID, gamemode, trackType, trackNum, style], references: [mapID, gamemode, trackType, trackNum, style], onDelete: Cascade)\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Restrict)\n  userID Int\n\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int\n\n  gamemode  Int @db.SmallInt\n  trackType Int @db.SmallInt\n  trackNum  Int @db.SmallInt\n  style     Int @db.SmallInt\n\n  /// We don't store ticks in anticipation of future sub-tick system. If ticks\n  /// are required, they can be calculated with `time * tickrate of gamemode`.\n  time Float @db.DoublePrecision\n\n  /// We store this for LeaderboardRun and *not* PastRun for space efficiency.\n  splits Json /// RunSplits model\n\n  // validated  Boolean // TODO: We'll be using this in future and blocking a bunch of stuff from DTO if false\n  replayHash String? @db.Char(40) /// SHA1\n\n  /// Flags are all the styles are run qualifies for. A styled run may qualify\n  /// for multiple leaderboards, and an separate entry is made for each.\n  /// For example, a sideways surf run (for some track) would be added to the\n  /// sideways leaderboard and unstyled leaderboard. This field is used to \"tag\"\n  /// runs one leaderboard as also qualifying for another, e.g. the sideways\n  /// run would get a \"Sideways\" tag on the unstyled leaderboard.\n  // This is an array because (a) it allows easier queries for specific flag(s)\n  // in Prisma (writing the paginated PastRuns get query raw would be really\n  // rough, though we could if absolutely needed), (b) we could conceivable\n  // exceed 64 flags at some point. This is of course a very large table where\n  // we care about size a great deal, though we expect the *majority* of runs\n  // to not to have any non-zero flags.\n  // If we need to cut back on the size of this table in the future, we could\n  // consider moving this to a Flags (or adopting pguint for small values).\n  // But most runs submitted will not to have any flags, so it's probably okay.\n  flags Int[] @db.SmallInt\n\n  rank Int @db.Integer // TODO: SoonTM we'll stop storing this and just use a window function over the `time` column.\n\n  createdAt DateTime @default(now())\n\n  pastRun   PastRun? @relation(fields: [pastRunID], references: [id])\n  pastRunID BigInt?  @unique\n\n  // Tempting to add a (userID, createdAt) index here for e.g. user profile\n  // page, but the PK index starting with `userID` will do some of the work\n  // anyway, proooobably not worth the space. Worth testing out on live DB in\n  // future!\n\n  // Unique index starting with userID then profile, for queries like a user's\n  // run history.\n  @@id([userID, gamemode, style, mapID, trackType, trackNum])\n  @@index([mapID, gamemode, trackType, trackNum, style, time(sort: Asc), createdAt(sort: Asc)])\n}\n\n/// Very similar to `LeaderboardRun`, but also includes non-PB runs, and\n/// therefore doesn't really correspond to a leaderboard - rather all the runs\n///that ever qualified for that leaderboard in the past. Used for tracking\n/// user's run history.\nmodel PastRun {\n  // We could use a composite PK here as `LeaderboardRun` does, using createdAt\n  // in the key to ensure uniqueness, but that has several disadvantages:\n  //   - Postgres would have to handle a much more expensive unique index, on\n  //     a table with very frequent inserts - doubling the already painful cost\n  //     of inserts into the LBRun table.\n  //   - To maintain a relation between LBRuns and PastRuns (which we use), we'd\n  //     need a uniqueness constraint on LeaderboardRun consisting of the\n  //     current PK, with createdAt tacked the end - since Prisma/Postgres can't\n  //     infer that [userID, gamemode, style, mapID, trackType, trackNum, createdAt]\n  //     is unique from [userID, gamemode, style, mapID, trackType, trackNum]\n  //     being unique. So we'd have add another very expensive index on\n  //     LBRun, or make the PK include createdAt as well, but losing the\n  //     uniqueness *without* the createdAt makes backend code more annoying\n  //     and frustrating not to have enforced by the DB.\n  //   - HTTP queries for specific PastRuns would have to include the\n  //     createdAt.\n  //   - Using a createdAt in a PK just feels wrong.\n  // For now we're not querying this table all that often (the game never does,\n  // and nobody even uses the frontend) so we should prioritize speedy inserts\n  // over selects - so a incrementing int PK makes the most sense. If we find\n  // ourselves querying this more in the future (depends what direction game UI\n  // goes in), we should consider more indexing or maybe switching a composite\n  // PK.\n  id BigInt @id @default(autoincrement())\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Restrict)\n  userID Int\n\n  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)\n  mapID Int\n\n  gamemode  Int @db.SmallInt\n  trackType Int @db.SmallInt\n  trackNum  Int @db.SmallInt\n  style     Int @db.SmallInt\n\n  time Float @db.DoublePrecision\n\n  flags Int[] @db.SmallInt\n\n  leaderboardRun LeaderboardRun?\n\n  createdAt DateTime @default(now())\n\n  // Index for any query that's not specific to a user. But since id is strongly\n  // correlated with insertion date (so stuff is generally on same index pages),\n  // we probably don't gain much from this - worth testing at some point.\n  // @@index([createdAt(sort: Desc)])\n\n  // Not adding more fields to this index due to its size and frequency of\n  // insertion. [userID, createdAt, gamemode, style, mapID, trackType, trackNum]\n  // would speed up fetches quite a lot, but is an expensive index that'd hurt\n  // insertion times during run submission a lot.\n  // If we do a per-gamemode user page in the game UI in the future (that'd be\n  // queried *very* frequently and is user-specific so bad caching), indexing\n  // over [userID, gamemode, createdAt(desc)] would make a lot of sense.\n  @@index([userID])\n}\n\nmodel AdminActivity {\n  id Int @id @default(autoincrement())\n\n  comment String?\n  type    Int\n  target  BigInt  @db.BigInt\n  oldData Json\n  newData Json\n\n  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)\n  userID Int\n\n  createdAt DateTime @default(now())\n}\n\n/// Not standard SQL practice but whatever, this is a solid way to persist\n/// config\nmodel Config {\n  id    String @id\n  value Json\n}\n",
  "inlineSchemaHash": "2a8f850eb90366d9c05e4fbeb56d8b1e8c4c0f43397f8484fb78e1d6ec79bad8",
  "copyEngine": true,
  "runtimeDataModel": {
    "models": {},
    "enums": {},
    "types": {}
  },
  "dirname": ""
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"roles\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"bans\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"steamID\",\"kind\":\"scalar\",\"type\":\"BigInt\"},{\"name\":\"alias\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"avatar\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"country\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"profile\",\"kind\":\"object\",\"type\":\"Profile\",\"relationName\":\"ProfileToUser\"},{\"name\":\"userStats\",\"kind\":\"object\",\"type\":\"UserStats\",\"relationName\":\"UserToUserStats\"},{\"name\":\"submittedMaps\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToUser\"},{\"name\":\"submittedMapDates\",\"kind\":\"object\",\"type\":\"MapSubmissionDate\",\"relationName\":\"MapSubmissionDateToUser\"},{\"name\":\"submittedMapVersions\",\"kind\":\"object\",\"type\":\"MapVersion\",\"relationName\":\"MapVersionToUser\"},{\"name\":\"mapCredits\",\"kind\":\"object\",\"type\":\"MapCredit\",\"relationName\":\"MapCreditToUser\"},{\"name\":\"mapFavorites\",\"kind\":\"object\",\"type\":\"MapFavorite\",\"relationName\":\"MapFavoriteToUser\"},{\"name\":\"activities\",\"kind\":\"object\",\"type\":\"Activity\",\"relationName\":\"ActivityToUser\"},{\"name\":\"follows\",\"kind\":\"object\",\"type\":\"Follow\",\"relationName\":\"follow_follow\"},{\"name\":\"followers\",\"kind\":\"object\",\"type\":\"Follow\",\"relationName\":\"follow_follower\"},{\"name\":\"mapNotifies\",\"kind\":\"object\",\"type\":\"MapNotify\",\"relationName\":\"MapNotifyToUser\"},{\"name\":\"notifications\",\"kind\":\"object\",\"type\":\"Notification\",\"relationName\":\"notifs_to\"},{\"name\":\"notifsAbout\",\"kind\":\"object\",\"type\":\"Notification\",\"relationName\":\"notifs_about\"},{\"name\":\"leaderboardRuns\",\"kind\":\"object\",\"type\":\"LeaderboardRun\",\"relationName\":\"LeaderboardRunToUser\"},{\"name\":\"pastRuns\",\"kind\":\"object\",\"type\":\"PastRun\",\"relationName\":\"PastRunToUser\"},{\"name\":\"reportSubmitted\",\"kind\":\"object\",\"type\":\"Report\",\"relationName\":\"report_submitter\"},{\"name\":\"reportResolved\",\"kind\":\"object\",\"type\":\"Report\",\"relationName\":\"report_resolver\"},{\"name\":\"testInvites\",\"kind\":\"object\",\"type\":\"MapTestInvite\",\"relationName\":\"MapTestInviteToUser\"},{\"name\":\"reviewsSubmitted\",\"kind\":\"object\",\"type\":\"MapReview\",\"relationName\":\"mapreview_reviewer\"},{\"name\":\"reviewsResolved\",\"kind\":\"object\",\"type\":\"MapReview\",\"relationName\":\"mapreview_resolver\"},{\"name\":\"reviewComments\",\"kind\":\"object\",\"type\":\"MapReviewComment\",\"relationName\":\"MapReviewCommentToUser\"},{\"name\":\"adminActivities\",\"kind\":\"object\",\"type\":\"AdminActivity\",\"relationName\":\"AdminActivityToUser\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Profile\":{\"fields\":[{\"name\":\"bio\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"socials\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"ProfileToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"}],\"dbName\":null},\"UserStats\":{\"fields\":[{\"name\":\"totalJumps\",\"kind\":\"scalar\",\"type\":\"BigInt\"},{\"name\":\"totalStrafes\",\"kind\":\"scalar\",\"type\":\"BigInt\"},{\"name\":\"level\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"cosXP\",\"kind\":\"scalar\",\"type\":\"BigInt\"},{\"name\":\"mapsCompleted\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"runsSubmitted\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"UserToUserStats\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"}],\"dbName\":null},\"DeletedUser\":{\"fields\":[{\"name\":\"steamIDHash\",\"kind\":\"scalar\",\"type\":\"String\"}],\"dbName\":null},\"Report\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"type\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"data\",\"kind\":\"scalar\",\"type\":\"BigInt\"},{\"name\":\"category\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"message\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"resolved\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"resolutionMessage\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"submitter\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"report_submitter\"},{\"name\":\"submitterID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"resolver\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"report_resolver\"},{\"name\":\"resolverID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Activity\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"type\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"data\",\"kind\":\"scalar\",\"type\":\"BigInt\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"ActivityToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Follow\":{\"fields\":[{\"name\":\"notifyOn\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"followed\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"follow_follower\"},{\"name\":\"followedID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"followee\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"follow_follow\"},{\"name\":\"followeeID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Notification\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"type\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"isRead\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"json\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"notifiedUser\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"notifs_to\"},{\"name\":\"notifiedUserID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"notifs_about\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"map\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToNotification\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"review\",\"kind\":\"object\",\"type\":\"MapReview\",\"relationName\":\"MapReviewToNotification\"},{\"name\":\"reviewID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"reviewComment\",\"kind\":\"object\",\"type\":\"MapReviewComment\",\"relationName\":\"MapReviewCommentToNotification\"},{\"name\":\"reviewCommentID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"MapNotify\":{\"fields\":[{\"name\":\"notifyOn\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapNotify\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"MapNotifyToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"MMap\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"name\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"status\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"images\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"submitter\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"MMapToUser\"},{\"name\":\"submitterID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"stats\",\"kind\":\"object\",\"type\":\"MapStats\",\"relationName\":\"MMapToMapStats\"},{\"name\":\"info\",\"kind\":\"object\",\"type\":\"MapInfo\",\"relationName\":\"MMapToMapInfo\"},{\"name\":\"currentVersion\",\"kind\":\"object\",\"type\":\"MapVersion\",\"relationName\":\"current_version\"},{\"name\":\"currentVersionID\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"versions\",\"kind\":\"object\",\"type\":\"MapVersion\",\"relationName\":\"MMapToMapVersion\"},{\"name\":\"leaderboards\",\"kind\":\"object\",\"type\":\"Leaderboard\",\"relationName\":\"LeaderboardToMMap\"},{\"name\":\"leaderboardRuns\",\"kind\":\"object\",\"type\":\"LeaderboardRun\",\"relationName\":\"LeaderboardRunToMMap\"},{\"name\":\"pastRuns\",\"kind\":\"object\",\"type\":\"PastRun\",\"relationName\":\"MMapToPastRun\"},{\"name\":\"credits\",\"kind\":\"object\",\"type\":\"MapCredit\",\"relationName\":\"MMapToMapCredit\"},{\"name\":\"favorites\",\"kind\":\"object\",\"type\":\"MapFavorite\",\"relationName\":\"MMapToMapFavorite\"},{\"name\":\"notifies\",\"kind\":\"object\",\"type\":\"MapNotify\",\"relationName\":\"MMapToMapNotify\"},{\"name\":\"notifsAbout\",\"kind\":\"object\",\"type\":\"Notification\",\"relationName\":\"MMapToNotification\"},{\"name\":\"reviews\",\"kind\":\"object\",\"type\":\"MapReview\",\"relationName\":\"MMapToMapReview\"},{\"name\":\"reviewStats\",\"kind\":\"object\",\"type\":\"MapReviewStats\",\"relationName\":\"MMapToMapReviewStats\"},{\"name\":\"submission\",\"kind\":\"object\",\"type\":\"MapSubmission\",\"relationName\":\"MMapToMapSubmission\"},{\"name\":\"testInvites\",\"kind\":\"object\",\"type\":\"MapTestInvite\",\"relationName\":\"MMapToMapTestInvite\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"MapVersion\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"versionNum\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"changelog\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"bspHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"zoneHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"bspDownloadId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"vmfDownloadId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"zones\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"submitterID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"submitter\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"MapVersionToUser\"},{\"name\":\"currentVersion\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"current_version\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapVersion\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"MapCredit\":{\"fields\":[{\"name\":\"type\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"description\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapCredit\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"MapCreditToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"}],\"dbName\":null},\"MapFavorite\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapFavorite\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"MapFavoriteToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"MapInfo\":{\"fields\":[{\"name\":\"description\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"youtubeID\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"creationDate\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"approvedDate\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"requiredGames\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapInfo\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"}],\"dbName\":null},\"MapStats\":{\"fields\":[{\"name\":\"reviews\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"subscriptions\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"plays\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"favorites\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"completions\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"uniqueCompletions\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"timePlayed\",\"kind\":\"scalar\",\"type\":\"BigInt\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapStats\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"}],\"dbName\":null},\"MapTestInvite\":{\"fields\":[{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapTestInvite\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"MapTestInviteToUser\"},{\"name\":\"state\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"MapSubmission\":{\"fields\":[{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapSubmission\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"type\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"suggestions\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"placeholders\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"dates\",\"kind\":\"object\",\"type\":\"MapSubmissionDate\",\"relationName\":\"MapSubmissionToMapSubmissionDate\"},{\"name\":\"discordReviewThread\",\"kind\":\"scalar\",\"type\":\"String\"}],\"dbName\":null},\"MapSubmissionDate\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"status\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"date\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"MapSubmissionDateToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"submission\",\"kind\":\"object\",\"type\":\"MapSubmission\",\"relationName\":\"MapSubmissionToMapSubmissionDate\"},{\"name\":\"submissionMapID\",\"kind\":\"scalar\",\"type\":\"Int\"}],\"dbName\":null},\"MapReview\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"mainText\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"comments\",\"kind\":\"object\",\"type\":\"MapReviewComment\",\"relationName\":\"MapReviewToMapReviewComment\"},{\"name\":\"suggestions\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"editHistory\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"imageIDs\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapReview\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"reviewer\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"mapreview_reviewer\"},{\"name\":\"reviewerID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"resolved\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"resolver\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"mapreview_resolver\"},{\"name\":\"resolverID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"approves\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"notifsAbout\",\"kind\":\"object\",\"type\":\"Notification\",\"relationName\":\"MapReviewToNotification\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"MapReviewComment\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"text\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"MapReviewCommentToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"review\",\"kind\":\"object\",\"type\":\"MapReview\",\"relationName\":\"MapReviewToMapReviewComment\"},{\"name\":\"reviewID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"notifsAbout\",\"kind\":\"object\",\"type\":\"Notification\",\"relationName\":\"MapReviewCommentToNotification\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"MapReviewStats\":{\"fields\":[{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToMapReviewStats\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"total\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"approvals\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"resolved\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"unresolved\",\"kind\":\"scalar\",\"type\":\"Int\"}],\"dbName\":null},\"Leaderboard\":{\"fields\":[{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"LeaderboardToMMap\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"gamemode\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"trackType\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"trackNum\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"style\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"tier\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"linear\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"type\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"tags\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"runs\",\"kind\":\"object\",\"type\":\"LeaderboardRun\",\"relationName\":\"LeaderboardToLeaderboardRun\"}],\"dbName\":null},\"LeaderboardRun\":{\"fields\":[{\"name\":\"leaderboard\",\"kind\":\"object\",\"type\":\"Leaderboard\",\"relationName\":\"LeaderboardToLeaderboardRun\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"LeaderboardRunToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"LeaderboardRunToMMap\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"gamemode\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"trackType\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"trackNum\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"style\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"time\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"splits\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"replayHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"flags\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"rank\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"pastRun\",\"kind\":\"object\",\"type\":\"PastRun\",\"relationName\":\"LeaderboardRunToPastRun\"},{\"name\":\"pastRunID\",\"kind\":\"scalar\",\"type\":\"BigInt\"}],\"dbName\":null},\"PastRun\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"BigInt\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"PastRunToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"mmap\",\"kind\":\"object\",\"type\":\"MMap\",\"relationName\":\"MMapToPastRun\"},{\"name\":\"mapID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"gamemode\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"trackType\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"trackNum\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"style\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"time\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"flags\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"leaderboardRun\",\"kind\":\"object\",\"type\":\"LeaderboardRun\",\"relationName\":\"LeaderboardRunToPastRun\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"AdminActivity\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"comment\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"type\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"target\",\"kind\":\"scalar\",\"type\":\"BigInt\"},{\"name\":\"oldData\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"newData\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"AdminActivityToUser\"},{\"name\":\"userID\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Config\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"value\",\"kind\":\"scalar\",\"type\":\"Json\"}],\"dbName\":null}},\"enums\":{},\"types\":{}}")
config.engineWasm = undefined

async function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {
  const { Buffer } = await import('node:buffer')
  const wasmArray = Buffer.from(wasmBase64, 'base64')
  return new WebAssembly.Module(wasmArray)
}

config.compilerWasm = {
  getRuntime: async () => await import("@prisma/client/runtime/query_compiler_bg.postgresql.js"),

  getQueryCompilerWasmModule: async () => {
    const { wasm } = await import("@prisma/client/runtime/query_compiler_bg.postgresql.wasm-base64.js")
    return await decodeBase64AsWasm(wasm)
  }
}




export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never

export interface PrismaClientConstructor {
    /**
   * ## Prisma Client
   * 
   * Type-safe database client for TypeScript
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  new <
    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    LogOpts extends LogOptions<Options> = LogOptions<Options>,
    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
  >(options?: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */

export interface PrismaClient<
  in LogOpts extends Prisma.LogLevel = never,
  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = Prisma.PrismaClientOptions['omit'],
  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): runtime.Types.Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): runtime.Types.Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Executes a typed SQL query and returns a typed result
   * @example
   * ```
   * import { myQuery } from '@prisma/client/sql'
   * 
   * const result = await prisma.$queryRawTyped(myQuery())
   * ```
   */
  $queryRawTyped<T>(typedSql: runtime.TypedSql<unknown[], T>): Prisma.PrismaPromise<T[]>

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>


  $extends: runtime.Types.Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.userStats`: Exposes CRUD operations for the **UserStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStats
    * const userStats = await prisma.userStats.findMany()
    * ```
    */
  get userStats(): Prisma.UserStatsDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.deletedUser`: Exposes CRUD operations for the **DeletedUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeletedUsers
    * const deletedUsers = await prisma.deletedUser.findMany()
    * ```
    */
  get deletedUser(): Prisma.DeletedUserDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapNotify`: Exposes CRUD operations for the **MapNotify** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapNotifies
    * const mapNotifies = await prisma.mapNotify.findMany()
    * ```
    */
  get mapNotify(): Prisma.MapNotifyDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mMap`: Exposes CRUD operations for the **MMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MMaps
    * const mMaps = await prisma.mMap.findMany()
    * ```
    */
  get mMap(): Prisma.MMapDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapVersion`: Exposes CRUD operations for the **MapVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapVersions
    * const mapVersions = await prisma.mapVersion.findMany()
    * ```
    */
  get mapVersion(): Prisma.MapVersionDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapCredit`: Exposes CRUD operations for the **MapCredit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapCredits
    * const mapCredits = await prisma.mapCredit.findMany()
    * ```
    */
  get mapCredit(): Prisma.MapCreditDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapFavorite`: Exposes CRUD operations for the **MapFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapFavorites
    * const mapFavorites = await prisma.mapFavorite.findMany()
    * ```
    */
  get mapFavorite(): Prisma.MapFavoriteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapInfo`: Exposes CRUD operations for the **MapInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapInfos
    * const mapInfos = await prisma.mapInfo.findMany()
    * ```
    */
  get mapInfo(): Prisma.MapInfoDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapStats`: Exposes CRUD operations for the **MapStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapStats
    * const mapStats = await prisma.mapStats.findMany()
    * ```
    */
  get mapStats(): Prisma.MapStatsDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapTestInvite`: Exposes CRUD operations for the **MapTestInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapTestInvites
    * const mapTestInvites = await prisma.mapTestInvite.findMany()
    * ```
    */
  get mapTestInvite(): Prisma.MapTestInviteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapSubmission`: Exposes CRUD operations for the **MapSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapSubmissions
    * const mapSubmissions = await prisma.mapSubmission.findMany()
    * ```
    */
  get mapSubmission(): Prisma.MapSubmissionDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapSubmissionDate`: Exposes CRUD operations for the **MapSubmissionDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapSubmissionDates
    * const mapSubmissionDates = await prisma.mapSubmissionDate.findMany()
    * ```
    */
  get mapSubmissionDate(): Prisma.MapSubmissionDateDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapReview`: Exposes CRUD operations for the **MapReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapReviews
    * const mapReviews = await prisma.mapReview.findMany()
    * ```
    */
  get mapReview(): Prisma.MapReviewDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapReviewComment`: Exposes CRUD operations for the **MapReviewComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapReviewComments
    * const mapReviewComments = await prisma.mapReviewComment.findMany()
    * ```
    */
  get mapReviewComment(): Prisma.MapReviewCommentDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.mapReviewStats`: Exposes CRUD operations for the **MapReviewStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapReviewStats
    * const mapReviewStats = await prisma.mapReviewStats.findMany()
    * ```
    */
  get mapReviewStats(): Prisma.MapReviewStatsDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.leaderboard`: Exposes CRUD operations for the **Leaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaderboards
    * const leaderboards = await prisma.leaderboard.findMany()
    * ```
    */
  get leaderboard(): Prisma.LeaderboardDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.leaderboardRun`: Exposes CRUD operations for the **LeaderboardRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderboardRuns
    * const leaderboardRuns = await prisma.leaderboardRun.findMany()
    * ```
    */
  get leaderboardRun(): Prisma.LeaderboardRunDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.pastRun`: Exposes CRUD operations for the **PastRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PastRuns
    * const pastRuns = await prisma.pastRun.findMany()
    * ```
    */
  get pastRun(): Prisma.PastRunDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.adminActivity`: Exposes CRUD operations for the **AdminActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminActivities
    * const adminActivities = await prisma.adminActivity.findMany()
    * ```
    */
  get adminActivity(): Prisma.AdminActivityDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.config`: Exposes CRUD operations for the **Config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs
    * const configs = await prisma.config.findMany()
    * ```
    */
  get config(): Prisma.ConfigDelegate<ExtArgs, { omit: OmitOpts }>;
}

export function getPrismaClientClass(dirname: string): PrismaClientConstructor {
  config.dirname = dirname
  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}
